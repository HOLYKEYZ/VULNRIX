"""
Professional Report Generation for VULNRIX.
Generates PDF, HTML, and SARIF format security reports.
"""

from typing import Dict, List, Optional
from datetime import datetime
import json


class ReportGenerator:
    """
    Generates professional security reports in multiple formats.
    """
    
    # OWASP Top 10 2021 mapping
    OWASP_TOP_10 = {
        'A01': {'name': 'Broken Access Control', 'cwes': ['CWE-200', 'CWE-201', 'CWE-352', 'CWE-639', 'CWE-918']},
        'A02': {'name': 'Cryptographic Failures', 'cwes': ['CWE-259', 'CWE-327', 'CWE-331', 'CWE-798']},
        'A03': {'name': 'Injection', 'cwes': ['CWE-77', 'CWE-78', 'CWE-79', 'CWE-89', 'CWE-94']},
        'A04': {'name': 'Insecure Design', 'cwes': ['CWE-209', 'CWE-256', 'CWE-501', 'CWE-522']},
        'A05': {'name': 'Security Misconfiguration', 'cwes': ['CWE-16', 'CWE-611', 'CWE-1004']},
        'A06': {'name': 'Vulnerable Components', 'cwes': ['CWE-1035', 'CWE-1104']},
        'A07': {'name': 'Auth Failures', 'cwes': ['CWE-287', 'CWE-384', 'CWE-613']},
        'A08': {'name': 'Data Integrity Failures', 'cwes': ['CWE-345', 'CWE-502', 'CWE-565']},
        'A09': {'name': 'Logging Failures', 'cwes': ['CWE-117', 'CWE-223', 'CWE-532', 'CWE-778']},
        'A10': {'name': 'SSRF', 'cwes': ['CWE-918']},
    }
    
    def __init__(self, scan_result: Dict, targets: Dict = None, report_type: str = 'technical'):
        self.scan_result = scan_result
        self.targets = targets or {}
        self.report_type = report_type  # 'executive', 'technical', 'compliance'
        self.generated_at = datetime.now()
    
    def map_to_owasp(self, cwe: str) -> Optional[Dict]:
        """Map a CWE to OWASP Top 10 category."""
        for owasp_id, data in self.OWASP_TOP_10.items():
            if cwe in data['cwes']:
                return {'id': owasp_id, 'name': data['name']}
        return None
    
    def calculate_severity_counts(self) -> Dict[str, int]:
        """Count findings by severity level."""
        counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        
        findings = self.scan_result.get('findings', [])
        for finding in findings:
            severity = finding.get('severity', 'low').lower()
            counts[severity] = counts.get(severity, 0) + 1
        
        return counts
    
    def calculate_owasp_breakdown(self) -> Dict[str, int]:
        """Group findings by OWASP Top 10 category."""
        breakdown = {k: 0 for k in self.OWASP_TOP_10.keys()}
        breakdown['Other'] = 0
        
        findings = self.scan_result.get('findings', [])
        for finding in findings:
            cwe = finding.get('cwe', '')
            owasp = self.map_to_owasp(cwe)
            if owasp:
                breakdown[owasp['id']] = breakdown.get(owasp['id'], 0) + 1
            else:
                breakdown['Other'] += 1
        
        return breakdown
    
    def generate_executive_summary(self) -> str:
        """Generate executive summary for C-suite."""
        counts = self.calculate_severity_counts()
        total = sum(counts.values())
        risk_score = self.scan_result.get('risk_score', 0)
        
        # Risk level text
        if risk_score >= 70:
            risk_level = "CRITICAL"
            risk_msg = "Immediate action required. Significant security vulnerabilities detected."
        elif risk_score >= 50:
            risk_level = "HIGH"
            risk_msg = "Priority attention needed. Multiple security issues found."
        elif risk_score >= 30:
            risk_level = "MEDIUM"
            risk_msg = "Some security improvements recommended."
        else:
            risk_level = "LOW"
            risk_msg = "Security posture is acceptable with minor improvements possible."
        
        return f"""
# Executive Summary

**Assessment Date:** {self.generated_at.strftime('%B %d, %Y')}
**Overall Risk Level:** {risk_level}
**Risk Score:** {risk_score}/100

## Key Findings

{risk_msg}

| Severity | Count |
|----------|-------|
| Critical | {counts['critical']} |
| High     | {counts['high']} |
| Medium   | {counts['medium']} |
| Low      | {counts['low']} |
| **Total**| **{total}** |

## Recommendations

1. Address all Critical and High severity findings within 7 days
2. Remediate Medium severity issues within 30 days
3. Schedule regular security assessments
4. Implement continuous monitoring

---
*Report generated by VULNRIX Security Platform*
"""
    
    def generate_technical_report(self) -> str:
        """Generate detailed technical report."""
        counts = self.calculate_severity_counts()
        owasp = self.calculate_owasp_breakdown()
        findings = self.scan_result.get('findings', [])
        
        # Build findings section
        findings_md = ""
        for i, finding in enumerate(findings, 1):
            owasp_cat = self.map_to_owasp(finding.get('cwe', ''))
            owasp_str = f" [{owasp_cat['id']}: {owasp_cat['name']}]" if owasp_cat else ""
            
            findings_md += f"""
### {i}. {finding.get('type', 'Unknown')} ({finding.get('severity', 'Unknown')})

**Location:** `{finding.get('file', 'unknown')}:{finding.get('line', 0)}`
**CWE:** {finding.get('cwe', 'N/A')}{owasp_str}

**Description:**
{finding.get('reason', 'No description provided.')}

**Vulnerable Code:**
```
{finding.get('code', 'N/A')}
```

**Recommendation:**
{finding.get('recommendation', 'Review and fix this vulnerability.')}

---
"""
        
        return f"""
# VULNRIX Security Assessment Report

**Generated:** {self.generated_at.strftime('%Y-%m-%d %H:%M:%S')}
**Report Type:** Technical Deep Dive
**Risk Score:** {self.scan_result.get('risk_score', 0)}/100

---

## Scan Summary

| Metric | Value |
|--------|-------|
| Files Scanned | {self.scan_result.get('files_scanned', 1)} |
| Scan Mode | {self.scan_result.get('mode', 'hybrid')} |
| Duration | {self.scan_result.get('scan_duration', 'N/A')} |

## Severity Distribution

| Severity | Count | Percentage |
|----------|-------|------------|
| Critical | {counts['critical']} | {(counts['critical']/max(sum(counts.values()),1)*100):.1f}% |
| High | {counts['high']} | {(counts['high']/max(sum(counts.values()),1)*100):.1f}% |
| Medium | {counts['medium']} | {(counts['medium']/max(sum(counts.values()),1)*100):.1f}% |
| Low | {counts['low']} | {(counts['low']/max(sum(counts.values()),1)*100):.1f}% |

## OWASP Top 10 Breakdown

| Category | Name | Findings |
|----------|------|----------|
{chr(10).join([f"| {k} | {self.OWASP_TOP_10[k]['name']} | {v} |" for k, v in owasp.items() if k != 'Other' and v > 0])}
| Other | Uncategorized | {owasp.get('Other', 0)} |

---

## Detailed Findings

{findings_md if findings_md else '*No vulnerabilities detected.*'}

---

## Remediation Priorities

### Immediate (0-7 days)
{chr(10).join(['- ' + f.get('type', 'Fix') + ' in ' + f.get('file', 'unknown') for f in findings if f.get('severity', '').lower() == 'critical'][:5]) or '- None'}

### High Priority (7-30 days)
{chr(10).join(['- ' + f.get('type', 'Fix') + ' in ' + f.get('file', 'unknown') for f in findings if f.get('severity', '').lower() == 'high'][:5]) or '- None'}

### Scheduled (30-90 days)
{chr(10).join(['- ' + f.get('type', 'Fix') + ' in ' + f.get('file', 'unknown') for f in findings if f.get('severity', '').lower() == 'medium'][:5]) or '- None'}

---

*This report was automatically generated by VULNRIX Security Platform.*
*For questions, contact security@vulnrix.com*
"""
    
    def to_sarif(self) -> Dict:
        """Convert to SARIF 2.1.0 format for GitHub/GitLab integration."""
        findings = self.scan_result.get('findings', [])
        rules_seen = set()
        rules = []
        results = []
        
        for finding in findings:
            rule_id = finding.get('cwe', 'VULN-001')
            
            # Add rule if not seen
            if rule_id not in rules_seen:
                owasp = self.map_to_owasp(rule_id)
                rules.append({
                    "id": rule_id,
                    "name": finding.get('type', 'Unknown'),
                    "shortDescription": {"text": finding.get('type', 'Unknown vulnerability')},
                    "fullDescription": {"text": finding.get('reason', '')},
                    "helpUri": f"https://cwe.mitre.org/data/definitions/{rule_id.replace('CWE-', '')}.html",
                    "properties": {
                        "owasp": owasp['id'] if owasp else None
                    }
                })
                rules_seen.add(rule_id)
            
            # Add result
            results.append({
                "ruleId": rule_id,
                "level": "error" if finding.get('severity', '').lower() in ['critical', 'high'] else "warning",
                "message": {"text": finding.get('reason', finding.get('type', 'Vulnerability detected'))},
                "locations": [{
                    "physicalLocation": {
                        "artifactLocation": {
                            "uri": finding.get('file', 'unknown'),
                            "uriBaseId": "%SRCROOT%"
                        },
                        "region": {
                            "startLine": finding.get('line', 1)
                        }
                    }
                }],
                "fixes": [{
                    "description": {"text": finding.get('recommendation', 'Fix this vulnerability')},
                }] if finding.get('recommendation') else []
            })
        
        return {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [{
                "tool": {
                    "driver": {
                        "name": "VULNRIX",
                        "semanticVersion": "2.0.0",
                        "informationUri": "https://vulnrix.com",
                        "rules": rules
                    }
                },
                "results": results
            }]
        }
    
    def to_html(self) -> str:
        """Generate HTML report."""
        content = self.generate_technical_report()
        
        # Convert markdown to basic HTML
        html_content = content.replace('# ', '<h1>').replace('\n## ', '</h1><h2>')
        html_content = html_content.replace('\n### ', '</h2><h3>').replace('\n---\n', '</h3><hr>')
        
        return f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VULNRIX Security Report - {self.generated_at.strftime('%Y-%m-%d')}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 0 auto; padding: 2rem; background: #0a0a0f; color: #fff; }}
        h1 {{ color: #00d4d4; border-bottom: 2px solid #00d4d4; padding-bottom: 0.5rem; }}
        h2 {{ color: #00d4d4; margin-top: 2rem; }}
        h3 {{ color: #e0e0e0; }}
        table {{ width: 100%; border-collapse: collapse; margin: 1rem 0; }}
        th, td {{ padding: 0.75rem; text-align: left; border-bottom: 1px solid #2a2a35; }}
        th {{ background: #1a1a24; color: #00d4d4; }}
        code {{ background: #1a1a24; padding: 0.25rem 0.5rem; border-radius: 4px; }}
        pre {{ background: #1a1a24; padding: 1rem; border-radius: 8px; overflow-x: auto; }}
        hr {{ border: none; border-top: 1px solid #2a2a35; margin: 2rem 0; }}
        .critical {{ color: #ef4444; }}
        .high {{ color: #f59e0b; }}
        .medium {{ color: #10b981; }}
        .low {{ color: #3b82f6; }}
    </style>
</head>
<body>
    <pre style="white-space: pre-wrap;">{content}</pre>
</body>
</html>
"""
    
    def to_csv(self) -> str:
        """Generate CSV export of findings."""
        findings = self.scan_result.get('findings', [])
        lines = ['Severity,Type,CWE,File,Line,Recommendation']
        
        for f in findings:
            rec = f.get('recommendation', '').replace('"', "'").replace('\n', ' ')
            lines.append(f'"{f.get("severity", "")}","{f.get("type", "")}","{f.get("cwe", "")}","{f.get("file", "")}",{f.get("line", 0)},"{rec}"')
        
        return '\n'.join(lines)
    
    def generate(self, format: str = 'markdown') -> str:
        """
        Generate report in specified format.
        
        Args:
            format: 'markdown', 'html', 'sarif', 'csv', or 'executive'
            
        Returns:
            Report content as string (or dict for SARIF)
        """
        if format == 'executive':
            return self.generate_executive_summary()
        elif format == 'markdown' or format == 'technical':
            return self.generate_technical_report()
        elif format == 'html':
            return self.to_html()
        elif format == 'sarif':
            return json.dumps(self.to_sarif(), indent=2)
        elif format == 'csv':
            return self.to_csv()
        else:
            return self.generate_technical_report()


# Convenience function
def generate_report(scan_result: Dict, format: str = 'markdown') -> str:
    """Generate a security report from scan results."""
    generator = ReportGenerator(scan_result)
    return generator.generate(format)
